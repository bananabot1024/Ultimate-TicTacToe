import java.util.*;

/**
 * 
 * @author yugreta3411
 * @period 1
 * 
 *         EasyAI class - Class that creates a EasyAI player object This player
 *         object makes a move (placing a game piece on the board) randomly with
 *         no strategy
 * 
 */

public class EasyAI extends Player {

	/**
	 * EasyAI constructor - Constructor that uses the super constructor to
	 * initialize the UltimateTicTacToeBoard the AI player will be playing on
	 * the AI player's game piece is also initialized
	 * 
	 * @param b
	 *            the UltimateTicTacToeBoard the player will be playing on
	 * @param p
	 *            the player's game piece
	 */

	public EasyAI(UltimateTicTacToeBoard b, GamePiece p) {
		super(b, p);
	}

	/**
	 * Method that has the computer make a random valid move in the same
	 * tic tac toe board the previous player made
	 * If the player goes first/there are no previous moves, the player can make a move anywhere
	 */
	public int[]  makeAMove(int[] lastMove) {
		Random number = new Random();
int[] where=new int[2];
		int outerR, outerC, innerR, innerC;
		outerR=lastMove[0];
		outerC=lastMove[1];
		innerR=number.nextInt(3);
		innerC=number.nextInt(3);

		for(int row=0; row<3; ++row){ //checks if the tic tac toe board of previous player is filled, so this player can work in new grid
			for(int col=0; col<3; ++col){
				if(checkValidity(outerR, outerC, row, col)){
					filled=false;
				}
			}
		}

		if(outerR==-1 || innerR==-1  || checkValidity(board, outerR, outerC, innerR, innerC)){
			if(outerR==-1 || outerC==-1){
				outerR=number.nextInt(3);
				outerC=number.nextInt(3);
			}
			board.setPieceAt(outerR, outerC, innerR, innerC, thisPlayersPiece);
		int[] where=new int[2];
where[0]=innerR;
where[1]=innerC;
return where;
		}else if(filled){
			int[] nextRec=int[2];
			do{
				nextRec[0]=outerR+1;
				nextRec[1]=outerR+1;
			return makeAMove(int[] nextRec);
		}else{
			return makeAMove(lastMove);
		}
		return lastMove;
}

/*		if(lastMove[0]==-1 || lastMove[1]==-1 ){ //checks if first/there are no previous moves
			outerR = number.nextInt(3);
			outerC = number.nextInt(3);
			innerR = number.nextInt(3);
			innerC = number.nextInt(3);
board.setPieceAt(outerR, outerC, innerR, innerC, thisPlayersPiece);
		int[] where=new int[2];
where[0]=innerR;
where[1]=innerC;
return where;
		}
		outerR=lastMove[0];
		outerC=lastMove[1];
		boolean filled=true;
		for(int row=0; row<3; ++row){ //checks if the tic tac toe board of previous player is filled, so this player can work in new grid
			for(int col=0; col<3; ++col){
				if(checkValidity(outerR, outerC, row, col)){
					filled=false;
				}
			}
}
if(!filled){
do {
			innerR = number.nextInt(3);
			innerC = number.nextInt(3);
		} while (!checkValidity(board, outerR, outerC, innerR, innerC));
		board.setPieceAt(outerR, outerC, innerR, innerC, thisPlayersPiece);
		int[] where=new int[2];
where[0]=innerR;
where[1]=innerC;
return where;

}
		do {
			outerR = number.nextInt(3);
			outerC = number.nextInt(3);
			innerR = number.nextInt(3);
			innerC = number.nextInt(3);
		} while (!checkValidity(board, outerR, outerC, innerR, innerC));
		board.setPieceAt(outerR, outerC, innerR, innerC, thisPlayersPiece);
		int[] where=new int[2];
where[0]=innerR;
where[1]=innerC;
return where;

	}
}
*/
